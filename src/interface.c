#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <stdio.h>
#include <dirent.h>

#include <libxml2/libxml/parser.h>
#include <libxml2/libxml/tree.h>

#include "interface.h"
#include "synth.h"


/*
 * Renders the global informations and menus about the synthesizer :
 * - ADSR envelope sliders
 * - Filter ADSR envelope sliders
 * - Oscillator waveforms dropdown menus
 * - Filter cutoff and filter envelope ON/OFF
 * - Amplification and detune effect
 */
void 
render_informations(params_t *params)
{
    /* ADSR envelope sliders */
    GuiGroupBox((Rectangle){ 30, 30, WIDTH / 2 - 50, 160 }, "ADSR Envelope");

    GuiLabel((Rectangle){ 155, 40, 100, 20}, "Attack");
    GuiSlider((Rectangle){ 60, 60, 225, 40 }, NULL, NULL, 
            params->attack, 0.0f, 2.0f);

    GuiLabel((Rectangle){ 155, 110, 100, 20}, "Decay");
    GuiSlider((Rectangle){ 60, 130, 225, 40 }, NULL, NULL, 
            params->decay, 0.0f, 2.0f);

    GuiLabel((Rectangle){ 415, 40, 100, 20}, "Sustain");
    GuiSlider((Rectangle){ 320, 60, 225, 40 }, NULL, NULL,
            params->sustain, 0.0f, 1.0f);

    GuiLabel((Rectangle){ 415, 110, 100, 20}, "Release");
    GuiSlider((Rectangle){ 320, 130, 225, 40 }, NULL, NULL, 
            params->release, 0.0f, 1.0f);

    /* Filter ADSR envelope sliders */
    GuiGroupBox((Rectangle){ 625, 30, WIDTH / 2 - 50, 160 }, "Filter ADSR Envelope");

    GuiLabel((Rectangle){ 750, 40, 100, 20}, "Attack");
    GuiSlider((Rectangle){ 655, 60, 225, 40 }, NULL, NULL, 
            params->synth->filter->adsr->attack, 0.0f, 2.0f);

    GuiLabel((Rectangle){ 750, 110, 100, 20}, "Decay");
    GuiSlider((Rectangle){ 655, 130, 225, 40 }, NULL, NULL, 
            params->synth->filter->adsr->decay, 0.0f, 2.0f);

    GuiLabel((Rectangle){ 1010, 40, 100, 20}, "Sustain");
    GuiSlider((Rectangle){ 915, 60, 225, 40 }, NULL, NULL, 
            params->synth->filter->adsr->sustain, 0.0f, 1.0f);

    GuiLabel((Rectangle){ 1010, 110, 100, 20}, "Release");
    GuiSlider((Rectangle){ 915, 130, 225, 40 }, NULL, NULL, 
            params->synth->filter->adsr->release, 0.0f, 1.0f);

    /* Oscillators waveforms */
    GuiGroupBox((Rectangle){ 30, 220, WIDTH / 2 - 50, 160 }, "Oscillators");

    GuiLabel((Rectangle){80, 255, 110, 20}, "Oscillator A");
    if (GuiDropdownBox((Rectangle){60, 275, 140, 40 }, 
        "#01#Sine wave;#02#Square wave;#03#Triangle wave;#04#Sawtooth wave", 
        params->dropbox_a, *params->dropbox_a_b))
    {
        *params->dropbox_a_b = !*params->dropbox_a_b;
    }
    for (int v = 0; v < VOICES; v++)
        params->synth->voices[v].oscillators[0].wave = *params->dropbox_a;

    GuiLabel((Rectangle){250, 255, 110, 20}, "Oscillator B");
    if (GuiDropdownBox((Rectangle){230, 275, 140, 40 }, 
        "#01#Sine wave;#02#Square wave;#03#Triangle wave;#04#Sawtooth wave", 
        params->dropbox_b, *params->dropbox_b_b))
    {
        *params->dropbox_b_b = !*params->dropbox_b_b;
    }
    for (int v = 0; v < VOICES; v++)
            params->synth->voices[v].oscillators[1].wave = *params->dropbox_b;

            
    GuiLabel((Rectangle){420, 255, 110, 20}, "Oscillator C");
    if (GuiDropdownBox((Rectangle){400, 275, 140, 40 }, 
        "#01#Sine wave;#02#Square wave;#03#Triangle wave;#04#Sawtooth wave", 
        params->dropbox_c, *params->dropbox_c_b))
    {
        *params->dropbox_c_b = !*params->dropbox_c_b;
    }
    for (int v = 0; v < VOICES; v++)
            params->synth->voices[v].oscillators[2].wave = *params->dropbox_c;


    /* Synth parameters */
    GuiGroupBox((Rectangle){ 625, 220, WIDTH / 2 - 50, 160 }, "Synth parameters");

    GuiLabel((Rectangle){ 750, 230, 100, 20}, "Cutoff");
    GuiSlider((Rectangle){ 655, 250, 225, 40 }, NULL, NULL, 
            &params->synth->filter->cutoff, 0.0f, 1.0f);

    GuiLabel((Rectangle){ 750, 300, 100, 20}, "Detune");
    GuiSlider((Rectangle){ 655, 320, 225, 40 }, NULL, NULL, 
            &params->synth->detune, 0.0f, 1.0f);

    GuiLabel((Rectangle){ 1010, 230, 100, 20}, "Amp");
    GuiSlider((Rectangle){ 915, 250, 225, 40 }, NULL, NULL, 
            &params->synth->amp, 0.0f, 1.0f);

    GuiCheckBox((Rectangle){915, 320, 40, 40}, "Filter envelope", 
            &params->synth->filter->env);


    if (GuiButton((Rectangle){ 1010, 320, 80, 40 }, "Save preset"))
    {
        *params->saving_preset = true;
    }

    if (GuiButton((Rectangle){ 1010, 420, 80, 40 }, "Load preset"))
    {
        load_preset(params);
    }

    if (*params->saving_preset)
        save_preset(params);
}


/* Renders the waveform generated by the render_synth function */
void 
render_waveform(short *buffer)
{
    GuiGroupBox((Rectangle){ 30, 410, WIDTH - 55, 160}, "Waveform");

    int mid_y = HEIGHT / 4 + 25;
    int y = HEIGHT / 3 + mid_y;

    int step = 1;

    for (int i = 13; i < FRAMES - 11; i += step)
    {
        int x1 = (i * WIDTH) / FRAMES;
        int x2 = ((i + step) * WIDTH) / FRAMES;

        int y1 = y - ((buffer[i] * mid_y) / 32768);
        int y2 = y - ((buffer[i + step] * mid_y) / 32768);

        /* Preventing going past the GuiGroupBox */
        if (y1 < 410) y1 = 410;
        if (y2 < 410) y2 = 410;
        if (y1 > 570) y1 = 570;
        if (y2 > 570) y2 = 570;

        DrawLine(x1, y1, x2, y2, BLACK);
    }
}

/* Render the white keys from the MIDI piano visualizer */
void 
render_white_keys()
{
    for (int i = 0; i < WHITE_KEYS; i++)
    {
        DrawRectangleLines(i * WHITE_KEYS_WIDTH, HEIGHT - WHITE_KEYS_HEIGHT, 
            WHITE_KEYS_WIDTH + 1, WHITE_KEYS_HEIGHT, BLACK);   
    }
}

/* Render the black keys from the MIDI piano visualizer */
void 
render_black_keys()
{
    char black_keys_pattern[] = {1, 1, 0, 1, 1, 1, 0, 0};
    int white_key_index = 0;
    for (int octave = 0; octave <= (WHITE_KEYS / 7); octave++)
    {
        for (int i = 0; i < 7; i++)
        {
            if (black_keys_pattern[i])
            {
                int x = (white_key_index * WHITE_KEYS_WIDTH) + WHITE_KEYS_WIDTH - (BLACK_KEYS_WIDTH / 2);
                DrawRectangle(x, HEIGHT - WHITE_KEYS_HEIGHT,
                                BLACK_KEYS_WIDTH, BLACK_KEYS_HEIGHT, BLACK);
            }
            white_key_index++;
            if (white_key_index >= WHITE_KEYS)
                break;
        }
        if (white_key_index >= WHITE_KEYS)
            break;
    }
}

/* Renders given note into a pressed key in the MIDI piano visualizer */
void 
render_key(int midi_note)
{
    int width = 0, height = 0, x = 0, y = 0, is_black = 0;
    get_key_position(midi_note, &x, &y, &width, &height, &is_black);

    DrawRectangle(x, y, width, height, (Color){151, 232, 255, 255});
    DrawRectangleLines(x, y, width, height, BLACK);
    /* Avoid double thick line */
    if (!is_black) DrawLine(x + width, y, x + width, y + height - 1, (Color){151, 232, 255, 255});
}

/* Outputs a given MIDI note rectangle parameters (x, y, width and height) */
void 
get_key_position(int midi_note, int *x, int *y, 
                int *width, int *height, int *is_black)
{
    int note_in_octave = midi_note % 12;
    int octave = midi_note / 12;

    static const int black_keys[] = {0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0};
    *is_black = black_keys[note_in_octave];

    static const int white_key_map[] = {0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6};
    int white_key_in_octave = white_key_map[note_in_octave];

    int white_key_index = (octave * 7) + white_key_in_octave;

    if (*is_black)
    {
        *width = WHITE_KEYS_WIDTH / 2;
        *height = (WHITE_KEYS_HEIGHT * 2) / 3;
        *x = (white_key_index * WHITE_KEYS_WIDTH) + WHITE_KEYS_WIDTH - (*width / 2);
        *y = HEIGHT - WHITE_KEYS_HEIGHT;
    }
    else
    {
        *width = WHITE_KEYS_WIDTH;
        *height = WHITE_KEYS_HEIGHT;
        *x = white_key_index * WHITE_KEYS_WIDTH;
        *y = HEIGHT - WHITE_KEYS_HEIGHT;
    }
}

/* Returns if a MIDI note is a assigned to a black key or not */
int 
is_black_key(int midi_note)
{
    int note = midi_note % 12;
    return (note == 1 || note == 3 || note == 6 || note == 8 || note == 10);
}

int 
save_preset(params_t *params)
{
    char filename[1024] = "presets/";

    int res = GuiTextInputBox((Rectangle){ WIDTH / 2 - 100, HEIGHT / 2 - 50, 200, 100}, "Preset name :", "", "Save preset", params->filename,  20, false); 

    if (res == 0)
        *params->saving_preset = false;
    else if (res == 1)
    {
        *params->saving_preset = false;
        strcat(filename, params->filename);
        strcat(filename, ".xml");

        char text_element[1024];

        xmlDocPtr doc = NULL;
        xmlNodePtr root_node = NULL;
        xmlNodePtr adsr_node = NULL;
        xmlNodePtr filter_node = NULL;
        xmlNodePtr filter_adsr_node = NULL;
        xmlNodePtr osc_node = NULL;
        xmlNodePtr effects_node = NULL;

        LIBXML_TEST_VERSION

        doc = xmlNewDoc(BAD_CAST "1.0");

        root_node = xmlNewNode(NULL, BAD_CAST "preset");
        xmlDocSetRootElement(doc, root_node);

        /* ADSR */
        adsr_node = xmlNewChild(root_node, NULL, BAD_CAST "adsr", NULL);
        /* Attack */
        snprintf(text_element, 1024, "%.2f", *params->attack);
        xmlNewChild(adsr_node, NULL, BAD_CAST "attack", BAD_CAST text_element);
        /* Decay */
        snprintf(text_element, 1024, "%.2f", *params->decay);
        xmlNewChild(adsr_node, NULL, BAD_CAST "decay", BAD_CAST text_element);
        /* Sustain */
        snprintf(text_element, 1024, "%.2f", *params->sustain);
        xmlNewChild(adsr_node, NULL, BAD_CAST "sustain", BAD_CAST text_element);
        /* Release */
        snprintf(text_element, 1024, "%.2f", *params->release);
        xmlNewChild(adsr_node, NULL, BAD_CAST "release", BAD_CAST text_element);

        /* Filter */
        filter_node = xmlNewChild(root_node, NULL, BAD_CAST "filter", NULL);
        /* Filter ADSR */
        filter_adsr_node = xmlNewChild(filter_node, NULL, BAD_CAST "filter_adsr", NULL);
        /* Attack */
        snprintf(text_element, 1024, "%.2f", *params->synth->filter->adsr->attack);
        xmlNewChild(filter_adsr_node, NULL, BAD_CAST "attack", BAD_CAST text_element);
        /* Decay */
        snprintf(text_element, 1024, "%.2f", *params->synth->filter->adsr->decay);
        xmlNewChild(filter_adsr_node, NULL, BAD_CAST "decay", BAD_CAST text_element);
        /* Sustain */
        snprintf(text_element, 1024, "%.2f", *params->synth->filter->adsr->sustain);
        xmlNewChild(adsr_node, NULL, BAD_CAST "sustain", BAD_CAST text_element);
        /* Release */
        snprintf(text_element, 1024, "%.2f", *params->synth->filter->adsr->release);
        xmlNewChild(filter_adsr_node, NULL, BAD_CAST "release", BAD_CAST text_element);
        /* Filter cutoff */
        snprintf(text_element, 1024, "%.2f", params->synth->filter->cutoff);
        xmlNewChild(filter_node, NULL, BAD_CAST "cutoff", BAD_CAST text_element);
        /* Filter envelope ON/OFF */
        snprintf(text_element, 1024, "%d", params->synth->filter->env);
        xmlNewChild(filter_node, NULL, BAD_CAST "envelope_on", BAD_CAST text_element);

        /* Oscillators waveforms */
        osc_node = xmlNewChild(root_node, NULL, BAD_CAST "oscillators", NULL);
        /* Oscillator A */
        snprintf(text_element, 1024, "%d", params->synth->voices[0].oscillators[0].wave);
        xmlNewChild(osc_node, NULL, BAD_CAST "osc_a", BAD_CAST text_element);
        /* Oscillator B */
        snprintf(text_element, 1024, "%d", params->synth->voices[0].oscillators[1].wave);
        xmlNewChild(osc_node, NULL, BAD_CAST "osc_b", BAD_CAST text_element);
        /* Oscillator C */
        snprintf(text_element, 1024, "%d", params->synth->voices[0].oscillators[2].wave);
        xmlNewChild(osc_node, NULL, BAD_CAST "osc_c", BAD_CAST text_element);

        /* Effects */
        effects_node = xmlNewChild(root_node, NULL, BAD_CAST "effects", NULL);
        /* Detune */
        snprintf(text_element, 1024, "%.2f", params->synth->detune);
        xmlNewChild(effects_node, NULL, BAD_CAST "detune", BAD_CAST text_element);
        /* Amplification */
        snprintf(text_element, 1024, "%.2f", params->synth->amp);
        xmlNewChild(effects_node, NULL, BAD_CAST "amp", BAD_CAST text_element);

        
        xmlSaveFormatFileEnc(filename, doc, "UTF-8", 1);
        xmlFreeDoc(doc);
        xmlCleanupParser();
        xmlMemoryDump();
    }
    
    return 0;
}

int 
load_preset(params_t *params)
{

    
    char filename[1024];
    FILE *f = popen("zenity --file-selection", "r");
    fgets(filename, 1024, f);
    filename[strcspn(filename, "\n")] = '\0';
    pclose(f);

    xmlDoc *doc = NULL;
    xmlNode *root = NULL;
    xmlNode *node = NULL;

    doc = xmlReadFile(filename, NULL, 0);

    if (doc == NULL)
    {
        fprintf(stderr, "failed to parse xml file.\n");
        return 1;
    }

    root = xmlDocGetRootElement(doc);

    for (node = root->children; node; node = node->next)
    {
        if (node->type == XML_ELEMENT_NODE &&
            xmlStrcmp(node->name, BAD_CAST "adsr") == 0)
        {
            parse_adsr(node, params, false);
        }
        else if (node->type == XML_ELEMENT_NODE &&
            xmlStrcmp(node->name, BAD_CAST "filter") == 0)
        {
            xmlNode *child = NULL;

            for (child = node->children; child; child = child->next)
            {
                if (child->type == XML_ELEMENT_NODE &&
                    xmlStrcmp(child->name, BAD_CAST "filter_adsr") == 0)
                {
                    parse_adsr(child, params, true);
                }
                else if (child->type == XML_ELEMENT_NODE && 
                        xmlStrcmp(child->name, BAD_CAST "cutoff") == 0)
                {
                    xmlChar *cutoff = xmlNodeGetContent(child);
                    char *end_ptr = NULL;
                    float cutoff_float = strtof((const char *)cutoff, &end_ptr);
                    if (end_ptr == (char *)cutoff)
                    {
                        fprintf(stderr, "bad cutoff value.\n");
                        return 1;
                    }
                    if (cutoff_float > 1.0) cutoff_float = 1.0;
                    else if (cutoff_float < 0.0) cutoff_float = 0.0;
                    params->synth->filter->cutoff = cutoff_float;
                }
                else if (child->type == XML_ELEMENT_NODE &&
                        xmlStrcmp(child->name, BAD_CAST "envelope_on") == 0)
                {
                    xmlChar *envelope_on = xmlNodeGetContent(child);
                    char *end_ptr = NULL;
                    int env_on_int = strtol((const char *)envelope_on, &end_ptr, 10);
                    if (end_ptr == (char *)envelope_on)
                    {
                        fprintf(stderr, "bad envelope value.\n");
                        return 1;
                    }
                    if (env_on_int > 1) env_on_int = 1;
                    else if (env_on_int < 0) env_on_int = 0;
                    params->synth->filter->env = env_on_int;
                }
            }
        }
        else if (node->type == XML_ELEMENT_NODE &&
                xmlStrcmp(node->name, BAD_CAST "oscillators") == 0)
        {
            xmlNode *child = NULL;

            for (child = node->children; child; child = child->next)
            {
                if (child->type == XML_ELEMENT_NODE &&
                    xmlStrcmp(child->name, BAD_CAST "osc_a") == 0)
                {
                    xmlChar *osc_a = xmlNodeGetContent(child);
                    char *end_ptr = NULL;
                    int osc_a_wave = strtol((const char *)osc_a, &end_ptr, 10);
                    if (end_ptr == (char *)osc_a)
                    {
                        fprintf(stderr, "bad osc a value.\n");
                        return 1;
                    }
                    if (osc_a_wave > 4) osc_a_wave = 4;
                    else if (osc_a_wave < 0) osc_a_wave = 0;
                    for (int v = 0; v < VOICES; v++)
                        params->synth->voices[v].oscillators[0].wave = osc_a_wave;
                }
                else if (child->type == XML_ELEMENT_NODE &&
                    xmlStrcmp(child->name, BAD_CAST "osc_b") == 0)
                {
                    xmlChar *osc_b = xmlNodeGetContent(child);
                    char *end_ptr = NULL;
                    int osc_b_wave = strtol((const char *)osc_b, &end_ptr, 10);
                    if (end_ptr == (char *)osc_b)
                    {
                        fprintf(stderr, "bad osc b value.\n");
                        return 1;
                    }
                    if (osc_b_wave > 3) osc_b_wave = 3;
                    else if (osc_b_wave < 0) osc_b_wave = 0;
                    for (int v = 0; v < VOICES; v++)
                        params->synth->voices[v].oscillators[1].wave = osc_b_wave;
                }
                else if (child->type == XML_ELEMENT_NODE &&
                    xmlStrcmp(child->name, BAD_CAST "osc_c") == 0)
                {
                    xmlChar *osc_c = xmlNodeGetContent(child);
                    char *end_ptr = NULL;
                    int osc_c_wave = strtol((const char *)osc_c, &end_ptr, 10);
                    if (end_ptr == (char *)osc_c)
                    {
                        fprintf(stderr, "bad osc b value.\n");
                        return 1;
                    }
                    if (osc_c_wave > 3) osc_c_wave = 3;
                    else if (osc_c_wave < 0) osc_c_wave = 0;
                    for (int v = 0; v < VOICES; v++)
                        params->synth->voices[v].oscillators[2].wave = osc_c_wave;
                }
            }
        }
        else if (node->type == XML_ELEMENT_NODE &&
                xmlStrcmp(node->name, BAD_CAST "effects") == 0)
        {
            xmlNode *child = NULL;
            for (child = node->children; child; child = child->next)
            {
                if (child->type == XML_ELEMENT_NODE &&
                    xmlStrcmp(child->name, BAD_CAST "detune") == 0)
                {
                    xmlChar *detune = xmlNodeGetContent(child);
                    char *end_ptr = NULL;
                    float detune_float = strtof((const char *)detune, &end_ptr);
                    if (end_ptr == (char *)detune)
                    {
                        fprintf(stderr, "bad cutoff value.\n");
                        return 1;
                    }
                    if (detune_float > 1.0) detune_float = 1.0;
                    else if (detune_float < 0.0) detune_float = 0.0;
                    params->synth->detune = detune_float;
                }
                else if (child->type == XML_ELEMENT_NODE &&
                        xmlStrcmp(child->name, BAD_CAST "amp") == 0)
                {
                    xmlChar *amp = xmlNodeGetContent(child);
                    char *end_ptr = NULL;
                    float amp_float = strtof((const char*)amp, &end_ptr);
                    if (end_ptr == (char *)amp)
                    {
                        fprintf(stderr, "bad cutoff value.\n");
                        return 1;
                    }
                    if (amp_float > 1.0) amp_float = 1.0;
                    else if (amp_float < 0.0) amp_float = 0.0;
                    params->synth->amp = amp_float;
                }
            }
        }
    }
    return 0;
}

int 
parse_adsr(xmlNode *adsr_root_node, params_t *params, bool filter)
{
    xmlNode *child = NULL;
    for (child = adsr_root_node->children; child; child = child->next)
    {
        if (child->type == XML_ELEMENT_NODE &&
            xmlStrcmp(child->name, BAD_CAST "attack") == 0)
        {
            xmlChar *attack = xmlNodeGetContent(child);
            char *end_ptr = NULL;
            float attack_float = strtof((const char*)attack, &end_ptr);
            if (end_ptr == (char *)attack)
            {
                fprintf(stderr, "bad attack value.\n");
                return 1;
            }
            if (attack_float > 2.0) attack_float = 2.0;
            else if (attack_float < 0.0) attack_float = 0.0;
            if (filter)
                *params->synth->filter->adsr->attack = attack_float;
            else
                *params->attack = attack_float;
        }
        else if (child->type == XML_ELEMENT_NODE &&
                xmlStrcmp(child->name, BAD_CAST "decay") == 0)
        {
            xmlChar *decay = xmlNodeGetContent(child);
            char *end_ptr = NULL;
            float decay_float = strtof((const char*)decay, &end_ptr);
            if (end_ptr == (char *)decay)
            {
                fprintf(stderr, "bad decay value.\n");
                return 1;
            }
            if (decay_float > 2.0) decay_float = 2.0;
            else if (decay_float < 0.0) decay_float = 0.0;
            if (filter)
                *params->synth->filter->adsr->decay = decay_float;
            else
                *params->decay = decay_float;
        }
        else if (child->type == XML_ELEMENT_NODE &&
                xmlStrcmp(child->name, BAD_CAST "sustain") == 0)
        {
            xmlChar *sustain = xmlNodeGetContent(child);
            char *end_ptr = NULL;
            float sustain_float = strtof((const char*)sustain, &end_ptr);
            if (end_ptr == (char *)sustain)
            {
                fprintf(stderr, "bad sustain value.\n");
                return 1;
            }
            if (sustain_float > 2.0) sustain_float = 2.0;
            else if (sustain_float < 0.0) sustain_float = 0.0;
            if (filter)
                *params->synth->filter->adsr->sustain = sustain_float;
            else
                *params->sustain = sustain_float;
        }
        else if (child->type == XML_ELEMENT_NODE &&
                xmlStrcmp(child->name, BAD_CAST "release") == 0)
        {
            xmlChar *release = xmlNodeGetContent(child);
            char *end_ptr = NULL;
            float release_float = strtof((const char*)release, &end_ptr);
            if (end_ptr == (char *)release)
            {
                fprintf(stderr, "bad release value.\n");
                return 1;
            }
            if (release_float > 2.0) release_float = 2.0;
            else if (release_float < 0.0) release_float = 0.0;
            if (filter)
                *params->synth->filter->adsr->release = release_float;
            else
                *params->release = release_float;
        }
    }
    return 0;
}
